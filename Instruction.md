<h2>Описание запуска проекта</h2>

В данном проекте я сделал небольшое fullstack приложение, которое имеет базовый UI с 
возможностью совершать действия в браузере, а также имеет API, который может быть
использован как напрямую через адресную строку, так и с помощью CURL. Оба споосба 
покажу в процессе объяснения. Проект контейнизирован через `Docker` и в пункте `8. Запуск приложения`
указал команду для `pull`


```bash
Table of Contents

1. Общее описание
2. Browser/UI часть
3. API часть
4. Как использовать CURL в описанных выше функциях:
5. Как использовать API в браузере:
6. Установка Flask Migrate
7. Тесты
8. Запуск приложения
9. Упоминание о System Design части проекта (
	вопросы из категории "Усложнения")
10. Tree проекта

```

<h4>Общее описание</h4>

1. В `requirements.txt` можно найти все необходимые библиотеки для установки. Чтобы установить их, необходимо 
ввести следующую команду в адресной строке: `pip install -r requirements.txt`

2. Также в самом низу можно будет увидеть структуру проекта, которую я сделал с помощью `tree` library.
3. В архитектурном плане я использовал `Application Factory`, так как это позволяет быстро менять конфигурации нашего проекта. Например, для development одна, а для production - другая. (см файл `config.py`)

4. В качетсве базы данных я использовал встроенную SQLite, однако, также я использовал flask migrations, чтобы
иметь доступ к разным версиям бд при необходимости. Подробную установку покажу далее.

5. Также для данного проекта я реши соврешать предзагрузку данных в бд и ограничил кол-во голосований
до 2. Другой вариант это создание голосваний через CURL и -X POST. 


<h4>Browser/UI часть</h4>

1. В данном проекте я использовал `wtf` формы, чтобы отображать информацию из бд. Обычно мы берем данные из форм и кладем их в бд, тут же мы, наоборот, достаем данные из бд и показываем их в форме. В качетсве формы я использовал QuerySelectField, которая дает возможность к mutiple-choice. 
Файл: `form.py`

2. В `models.py` можно найти модель бд. Примерную структуру я описал нижу:

``` bash
id | nickname | superPower | rating | poll_id

1    Pikachu     Fire          4         1
2    Oodish      Grass         7         2

```

Кратко опишу: `id` это наш Primary Key, который будет уникальным для каждого покемона.
`nickname` это имя и оно `unique=True`. `poll_id` как раз будет нашим отличительным признаком, который
позволит разделить первое и второе голосование.

Маленькое отступление: что дает `unqiue True`? Оно накладывает ограничение на колонку и не дает
 идентичному значению быть помещенным (выдает ошибку, проще говоря). Конечно, мы могли бы убрать его и тогда,
 используя `poll_id`, мы могли бы различать идентичные значения. Однако, QuerySelectField не дает использовать несколько колонок (отображать), поэтому я решил оставить как есть и просто вложить разные nickname для poll_id = 1 и `poll_id = 2`
 + это означает, что, например, в `poll_id=1` наши Primary Key будут 1,2,3. А в `poll_id=2` наши `Primary Key`будут 4,5,6

 + `serialize` методы используются в API части проекта для возврата данных в JSON формате.

 3. В `main_routes.py` содержится основная часть приложения. Перед каждым новым запуском приложения
 `@main_pokemons.before_app_first_request` будет проверять некий counter в отдельном файле, названным
 `cache`. Если counter <= 2, то новый poll будет создан. Если же counter превысил 2, то функция не будет делать действий. 

 **PS:** конечно, если мы вручную будет менять значения в counter, то это может привести к ошибкам. В общем, можно было бы сделать проверку на наличие данных в БД без внешнего файла, а через обычный запрос, как я сделал в API части проекта, но решил для разнообразия использовать такой метод.

 Когда пользователь выбирает покемона из списка предложенных, то приложение найдет его в нашей бд и увеличит counter у данного покемона. Далее будет `db.session.commit()`, чтобы сохранить изменения.

 4. В качетсве визуализации я использовал `jinja2` templates и  bootstrap с буквально крупицой css от меня. 
 Файл `home.html` будет нашим основным файлом, который будет "расширяться" парой других. При запуске приложения базовой страницей будет `poll.html`, который как раз отражает всех покемонов и QuerySelectField форму. `results.html` будет отображать всех покемонов в порядке уменьшения рейтинга. 


<h4>API часть</h4>

1. Мы "инициализируем" наш `api` Blueprint в отдельной папке, чтобы создать отдельную instance. 
В папке `main` есть файл `__init__.py`, который как раз таки и собирает все части воедино.
+ `url_prefix='/api'` здесь мы можем указать версию API, если такое необходимо: /api/v1. 

2. Чтобы следовать принципу **DRY** я вынес часто используемые/повторяющиеся функции в файл `utils.py`.

3. Первый метод: `create_poll()` дает возможность создать голосование через CURL, если мы используем POST метод.
`curl -X POST http://localhost:8000/api/createPoll`. Он также заполняет таблицы двумя версиями голосований. Только здесь проверка осуществляется без внешних файлов и мы делаем запрос в бд, чтобы понять наличие/отсутствие всех доступных голосований. Если 2 голосования уже созданы, то функция прсото вернет сообщения в JSON формате о максимально доступном числе голосований.

Также данная функция имеет GET метод, который при запросе будет выдавать JSON формат всех данных в порядке убывания.

Второй метод: `makeChoice(poll_id)`. Данный метод позволяет голосовать через CURL команду за покемона в одном из голосований. Здесь мы может вводить как `id`, так и `nickname`. Функция проверить наличие параметров, а при отсуствии/неверном формате выдаст ошибку в JSON формате. В ситуации, когда все хорошо, произойжет запрос в бд. Если здесь ошибка, то также вернется JSON с сообщением об ошибке. Если же опять все хорошо, то `rating` покемона увеличится и функция выдаст сообщение о том, что рейтинг такого-то покемона увеличен. 

Третий метод: `results(poll_id)`. Данный метод вернет информацию о состоянии голосования, однако, в отличии от GET метода в `create_poll()`, здесь будет информацию только об определенном голосовании с покемонами в порядке убывания рейтинга и также будет выведена только ифнормацию о `nickname` и `rating`. (тогда как в `create_poll()` все данные будут возвращены)


Как использовать `CURL` в описанных выше функциях:

1. Первый метод: `curl -X POST http://localhost:8000/api/createPoll`
2. Второй метод: 
	а) вернет JSON с ошибкой: `curl -d "identifier=1" -X POST http://localhost:8000/api/poll/4`
	b) Обе команды вернут покемона, у которого увеличили рейтинг:
		`curl -X POST  http://0.0.0.0:8000/api/poll/2?identifier=Wartortle`
		`curl -X POST  http://0.0.0.0:8000/api/poll/2?identifier=1`
3. Третий метод: `curl -X GET http://localhost:8000/api/getResult/2`
				 `curl -X GET http://localhost:8000/api/getResult/1`

Как использовать `API` в браузере:

1. запускаем `run.py`
2. К `http://0.0.0.0:8000` добавляем `/api` + наименование какого-то из методов.
Example: `http://0.0.0.0:8000/api/createPoll`; `http://0.0.0.0:8000/api/getResult/1`

**PS:** в браузере мы можем запустить только GET методы, тогда как через CURL доступны оба.


<h4>Установка Flask Migrate</h4>

Подробое описание делал для своего другого проекта. Описание можно найти здесь: [Ссылка](https://github.com/SleeplessChallenger/Flask_blog/blob/main/Flask_memos/Flask_Migrate.md)
<br>
Здесь кратко опишу шаги. В данном случае, если скачать мой проект, то доп действий делать не нужно, однако,
во избежании поломок я распишу как установить в проект migrations.

Заходим в папку `main` через `cd main`. 

А) Если бд еще нет
	- export FLASK_APP=__init__.py
	- flask db migrate
	- flask db upgrade

Б) Если бд уже создана

	- export FLASK_APP=__init__.py
	- flask db init
	- SQLALCHEMY_DATABASE_URI=sqlite:/// flask db migrate
	- flask db stamp head

В) Если все равно какие-то ошибки:
	- удалеяем файл migration вместе с бд
	- проделываем все из пункта А


<h4>Тесты</h4>

В `tests` folder можно найти тесты, которые я сделал для оценки проекта. Они включают как оценку БД, так и запросы.


<h4>Запуск:</h4>

1. Для того, чтобы забрать `Image` на локальную машину, вводим следующую команду:
	`docker pull enoshima/pokemon_vote:latest`

2. После того, как сделали `pull`, нам необходимо создать `container` из `image` на локальной машине. Для этого берем за основу следующую команду: `docker run --name cont -d -p 3000:3000 node_dir:latest`
Меняем имя/порты/image под соответствующие и запускаем. 
Например, `docker run --name pokemon_site -d -p 8000:8000 enoshima/pokemon_vote:latest`

3. Стоит сказать, что цифра в `cache.txt` > 2, следовательно новый poll создан не будет. При желании создать все с нуля, нужно сделать буквально пару действий: поставить цифру 1 в `main/static/cache.txt`, убрать `app.db`
из проекта. Тогда создасться новая БД при запуске web приложения.


<h4>SystemDesign_Усложнения</h4>

**Для просмотра моего ответа на System Design вопросы, см. файл `SystemDesign_Усложнения.md`**


<h4>Tree structure</h4>

```bash
├── Dockerfile
├── Instruction.md
├── SystemDesign_Уcложнения.md
├── docker-compose.yml
├── main
│   ├── __init__.py
│   ├── api
│   │   ├── __init__.py
│   │   ├── routes.py
│   │   └── utils.py
│   ├── app.db
│   ├── config.py
│   ├── form.py
│   ├── main_routes.py
│   ├── migrations
│   │   ├── README
│   │   ├── __pycache__
│   │   │   └── env.cpython-38.pyc
│   │   ├── alembic.ini
│   │   ├── env.py
│   │   ├── script.py.mako
│   │   └── versions
│   │       ├── 81f9c4bc2a85_.py
│   │       └── __pycache__
│   │           └── 81f9c4bc2a85_.cpython-38.pyc
│   ├── models.py
│   ├── static
│   │   ├── cache.txt
│   │   └── main.css
│   ├── templates
│   │   ├── home.html
│   │   ├── poll.html
│   │   └── results.html
│   └── test_app.db
├── requirements.txt
├── run.py
└── tests
    ├── __init__.py
    ├── test_basic.py
    ├── test_dbmodel.py
    └── test_routes.py
```
